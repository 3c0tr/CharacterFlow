1
01:00:08,958 --> 01:00:09,876
<b><font color='#ff9393'>在blender中制作风格像素化渲染其实是很适合的</font></b>

2
01:00:09,875 --> 01:00:10,791
<b><font color='#ff9393'>在blender中制作风格像素化渲染其实是很适合的</font></b>
<b><font color='#ff9393'>这期视频可能需要你对blender有一定的了解</font></b>

3
01:00:10,791 --> 01:00:11,708
<b><font color='#ff9393'>在blender中制作风格像素化渲染其实是很适合的</font></b>
<b><font color='#ff9393'>这期视频可能需要你对blender有一定的了解</font></b>
<b><font color='#ff9393'>视频中的每一个概念我都会提供简要的解释</font></b>

4
01:00:11,708 --> 01:00:12,625
<b><font color='#ff9393'>你需要以下的准备：</font></b>
<b><font color='#ff9393'>1.使用EEVEE着色器生成一切效果的决心</font></b>
<b><font color='#ff9393'>2.最好使用4.3.0以上的版本(有灯光排除)</font></b>
<b><font color='#ff9393'>3.一些简易的数学知识</font></b>


5
01:00:12,625 --> 01:00:14,416
<b><font color='#ff9393'>以及与blender搏斗，</font></b>
<b><font color='#ff9393'>做出理论上不该存在的效果的勇气</font></b>

6
01:00:20,500 --> 01:00:22,166
<b><font color='#ff9393'>在正式开始编写着色器之前要注意，</font></b>
<b><font color='#ff9393'>我们需要精准地控制摄像机发出的每一根射线</font></b>
<b><font color='#ff9393'>(也可以理解为一次采样)</font></b>


7
01:00:22,166 --> 01:00:24,375
<b><font color='#ff9393'>为了保证每次采样的坐标都是完全可控的，</font></b>
<b><font color='#ff9393'>同样地也是为了还原像素化风格</font></b>


8
01:00:24,375 --> 01:00:26,666
<b><font color='#ff9393'>你需要把"渲染->采样"的数目调为1</font></b>
<b><font color='#ff9393'>"渲染->胶片->过滤尺寸调为0"</font></b>


9
01:00:26,666 --> 01:00:32,750
<b><font color='#ff9393'>创建最常规的3渲2效果，并且应用在模型上</font></b>


10
01:00:32,750 --> 01:00:35,875
<b><font color='#ff9393'>就做出了最基本的卡通渐变效果</font></b>


11
01:00:35,875 --> 01:00:39,625
<b><font color='#ff9393'>但是假如想要还原类似这样的像素渐变效果</font></b>


12
01:00:39,625 --> 01:00:43,375
<b><font color='#ff9393'>即在渲染图像时每一个像素色块都会精准地维持指定的样式</font></b>


13
01:00:43,375 --> 01:00:46,375
<b><font color='#ff9393'>就需要使用“纹理坐标->窗口”来获取物体表面</font></b>
<b><font color='#ff9393'>在屏幕空间上的坐标</font></b>


14
01:00:46,375 --> 01:00:46,958
<b><font color='#ff9393'>理论上"纹理坐标->摄像机"与"摄像机数据->视图矢量"</font></b>
<b><font color='#ff9393'>也能做出同样的效果，但我遇到了奇怪的精度问题</font></b>


15
01:00:46,958 --> 01:00:50,000
<b><font color='#ff9393'>就像这样，现在能够精准地获取</font></b>
<b><font color='#ff9393'>物体表面上的点在屏幕空间中的坐标了</font></b>

16
01:00:50,000 --> 01:00:52,458
<b><font color='#ff9393'>表面的颜色是完全由在屏幕空间中的坐标决定的</font></b>

17
01:00:52,458 --> 01:00:55,291
<b><font color='#ff9393'>通过这些信息，就能够精准地做出任何想要的像素渐变样式</font></b>

18
01:00:55,500 --> 01:00:58,333
<b><font color='#ff9393'>"窗口"会提供当前物体表面在屏幕空间中的坐标</font></b>

19
01:00:58,333 --> 01:01:01,083
<b><font color='#ff9393'>屏幕左下角为(0.0,0.0)右上角为(1.0,1.0)</font></b>

20
01:01:01,083 --> 01:01:03,875
<b><font color='#ff9393'>进行分离XYZ的操作，X输出的范围是0.0-1.0</font></b>
<b><font color='#ff9393'>Y输出的范围也是0.0-1.0</font></b>

21
01:01:03,875 --> 01:01:07,666
<b><font color='#ff9393'>这时，如果你注意到，假如为X的值乘以渲染图象的宽度</font></b>
<b><font color='#ff9393'>为Y的值乘以渲染图象的高度</font></b>
<b><font color='#ff9393'>(假如渲染图象的尺寸为512x400)</font></b>

22
01:01:07,666 --> 01:01:10,833
<b><font color='#ff9393'>这样你的X与Y就精准地对应上了渲染图像上的每一个像素的坐标</font></b>
<b><font color='#ff9393'>范围为X 0-511 Y 0-399</font></b>

23
01:01:10,833 --> 01:01:13,458
<b><font color='#ff9393'>对于一些简单的需求，</font></b>
<b><font color='#ff9393'>比如我想制作在2x2范围内重复的像素渐变</font></b>


24
01:01:13,458 --> 01:01:15,666
<b><font color='#ff9393'>那就让X与Y对2取模，</font></b>
<b><font color='#ff9393'>让X与Y输出的结果在0或1之间循环</font></b>
<b><font color='#ff9393'>（如果你想创造3x3的图案，就对3取模，输出结果为0或1或2）</font></b>

25
01:01:15,666 --> 01:01:17,916
<b><font color='#ff9393'>注意到，X + 2Y能够表示出2x2区域中的任意的一块像素点</font></b>

26
01:01:17,916 --> 01:01:20,000
<b><font color='#ff9393'>通过X + 2Y的计算结果就能够完全操控这个像素的颜色</font></b>
<b><font color='#ff9393'>比如，把结果为0和2的像素赋值为1，就能够实现棋盘格的效果</font></b>

27
01:01:20,000 --> 01:01:23,083
<b><font color='#ff9393'>这就是X与Y都对2取模后，X + 2Y的图像</font></b>

28
01:01:23,083 --> 01:01:26,000
<b><font color='#ff9393'>这时输出的颜色代表了(X + 2Y) / 4的值</font></b>
<b><font color='#ff9393'>即0.0, 0.25, 0.50, 0.75 </font></b>
<b><font color='#ff9393'>X + 2Y的原始值为0, 1, 2, 3</font></b>


29
01:01:26,000 --> 01:01:28,666
<b><font color='#ff9393'>这里除以4只是为了让你直观地在图像上看到X + 2Y的值的变化</font></b>
<b><font color='#ff9393'>(毕竟blender无法表现出大于1.0的值的变化情况)</font></b>

30
01:01:28,666 --> 01:01:37,125
<b><font color='#ff9393'>就比如我现在就把X + 2Y值为0, 1, 2的像素设置为了白色</font></b>
<b><font color='#ff9393'>也可以把任意位置像素的输出结果设置为1</font></b>


31
01:01:37,125 --> 01:01:41,291
<b><font color='#ff9393'>这里再拿3x3的图案作为说明</font></b>
<b><font color='#ff9393'>这里是X与Y对3取模后，X + 3Y的输出结果</font></b>


32
01:01:41,291 --> 01:01:50,041
<b><font color='#ff9393'>如果把坐标为1,3,6的格子设置为白色，这就是最终的渲染结果</font></b>


33
01:01:50,041 --> 01:01:59,625
<b><font color='#ff9393'>如果你把坐标为1,3,6的格子设置为白色，这就是最终的渲染结果</font></b>
<b><font color='#ff9393'>你可以用这种方式创造任意大小，任意样式的图案</font></b>


34
01:01:59,625 --> 01:02:04,000
<b><font color='#ff9393'>完整节点如图所示</font></b>


35
01:02:04,000 --> 01:02:20,000
<b><font color='#ff9393'>这里还有一个使用图像纹理作为图案的版本</font></b>


36
01:02:20,000 --> 01:02:34,541
<b><font color='#ff9393'>这一切像素渐变图案都是在屏幕空间中创建的</font></b>
<b><font color='#ff9393'>所有无论在任何物体上，或是任何角度下，都是完全精准的</font></b>

37
01:02:34,541 --> 01:02:58,541
<b><font color='#ff9393'>然后就可以通过这种方式来让颜色渐变的中间部分</font></b>
<b><font color='#ff9393'>替换为指定的像素渐变样式</font></b>

38
01:03:02,500 --> 01:03:04,958
<b><font color='#ff9393'>在blender中有许多种常用的方式实现描边效果</font></b>

39
01:03:04,958 --> 01:03:07,791
<b><font color='#ff9393'>比如使用着色器菲涅尔节点，物体外侧反转法线，</font></b>
<b><font color='#ff9393'>使用蜡笔工具，合成器中使用边缘检测滤镜等方式</font></b>

40
01:03:07,791 --> 01:03:13,750
<b><font color='#ff9393'>但都与像素化的需求存在一些矛盾比如:</font></b>
<b><font color='#ff9393'>物体空间的描边方案无法渲染出精准宽度的边缘</font></b>
<b><font color='#ff9393'>通过图像滤镜实现的描边方案无法正确地识别物体边缘</font></b>

41
01:03:13,791 --> 01:03:15,750
<b><font color='#ff9393'>但是别担心，可以通过使用深度图制作描边滤镜</font></b>
<b><font color='#ff9393'>来完美避开以上几种方案在像素化方面的缺点</font></b>

42
01:03:15,750 --> 01:03:20,541
<b><font color='#ff9393'>首先来到合成器编辑器中，点击"启用节点"</font></b>
<b><font color='#ff9393'>再去右侧选项，将"精度"调整至"完整"</font></b>

43
01:03:20,541 --> 01:03:23,166
<b><font color='#ff9393'>再去"视图层->通道->数据->z"选项打上勾</font></b>
<b><font color='#ff9393'>就能够在合成器中获取场景的深度信息</font></b>

44
01:03:23,166 --> 01:03:25,125
<b><font color='#ff9393'>这里先简要解释一下什么是深度信息</font></b>

45
01:03:25,125 --> 01:03:27,083
<b><font color='#ff9393'>对于一个摄像机来说，</font></b>
<b><font color='#ff9393'>存在一个最小渲染范围，与一个最大渲染范围</font></b>

46
01:03:27,083 --> 01:03:29,875
<b><font color='#ff9393'>如果物体表面越靠近最大渲染范围，就会返回接近1.0的结果</font></b>
<b><font color='#ff9393'>越靠近最小渲染范围，就会返回接近0.0的结果</font></b>
<b><font color='#ff9393'>（去3D场景右上角的"着色方式->合成器->总是"即可实时预览合成结果）</font></b>

47
01:03:29,875 --> 01:03:32,750
<b><font color='#ff9393'>这样就能够在屏幕空间中获取每个像素位于摄像机的远近关系</font></b>

48
01:03:32,750 --> 01:03:34,708
<b><font color='#ff9393'>如果两个相邻的像素深度数值相差过大的话</font></b>
<b><font color='#ff9393'>就可以认为这两个像素不在同一个"图层"之上</font></b>

49
01:03:34,708 --> 01:03:36,708
<b><font color='#ff9393'>为其生成描边效果</font></b>

50
01:03:36,708 --> 01:03:40,000
<b><font color='#ff9393'>我使用这种方式在合成器节点中实现它</font></b>

51
01:03:40,000 --> 01:03:45,375
<b><font color='#ff9393'>对每一个像素的上下左右进行一次检测，</font></b>
<b><font color='#ff9393'>如果深度信息相差过大就将这个像素设置成黑色</font></b>

52
01:03:45,375 --> 01:03:53,958
<b><font color='#ff9393'>预览一下描边生成的遮罩的具体效果</font></b>
<b><font color='#ff9393'>(现在合成器支持GPU了，性能非常好)</font></b>

53
01:03:53,958 --> 01:03:58,958
<b><font color='#ff9393'>就这样就能为画面增加全局像素描边效果</font></b>

54
01:04:03,416 --> 01:04:06,041
<b><font color='#ff9393'>如果用单个点光源渲染一张平面</font></b>

55
01:04:06,041 --> 01:04:08,625
<b><font color='#ff9393'>就会出现这种非常规整而无趣的圆环效果</font></b>

56
01:04:08,625 --> 01:04:10,958
<b><font color='#ff9393'>这可真是太糟糕了不是吗？</font></b>

57
01:04:10,958 --> 01:04:15,708
<b><font color='#ff9393'>当然，也可以尝试加上一层噪波纹理，</font></b>
<b><font color='#ff9393'>变得很不错了，但我想更进一步</font></b>

58
01:04:15,708 --> 01:04:20,583
<b><font color='#ff9393'>如果以光源为中心，让光照效果呈现向外放射状，</font></b>
<b><font color='#ff9393'>这个主意或许不错</font></b>

59
01:04:20,583 --> 01:04:24,583
<b><font color='#ff9393'>首先，得想个办法在着色器中获取光照的方向</font></b>

60
01:04:24,583 --> 01:04:33,041
<b><font color='#ff9393'>但blender自带的着色器节点好像根本拿不到光照方向</font></b>

61
01:04:33,041 --> 01:04:38,000
<b><font color='#ff9393'>那就用"输入->物体信息"手动把光源物体的位置传进来吧</font></b>

62
01:04:38,000 --> 01:04:43,333
<b><font color='#ff9393'>糟了，这好像不是在几何节点里面，我选择物体的吸管呢？</font></b>

63
01:04:43,416 --> 01:04:45,500
<b><font color='#ff9393'>也没关系，总有方法能拿到想要的位置信息</font></b>

64
01:04:45,500 --> 01:04:48,291
<b><font color='#ff9393'>可以试试用"驱动器"传递几乎一切可见的数据</font></b>

65
01:04:48,291 --> 01:04:48,500
<b><font color='#ff9393'>可以试试用"驱动器"传递几乎一切可见的数据</font></b>
<b><font color='#ff9393'>(另一个例子是着色器节点里面其实也是无法获取渲染图象的宽高的，</font></b>
<b><font color='#ff9393'>你也可以拿驱动器为之前的像素渐变着色器自动传递渲染图象的宽高)</font></b>

66
01:04:48,500 --> 01:04:51,958
<b><font color='#ff9393'>我这里选择为物体创建一个名为lightPos的自定义属性，</font></b>
<b><font color='#ff9393'>设置为浮点数组，长度为3(刚好就是一个三维矢量)</font></b>

67
01:04:51,958 --> 01:04:55,291
<b><font color='#ff9393'>在着色器内部通过这种方式获取之前创建好的lightPos属性，</font></b>
<b><font color='#ff9393'>从而得到光源的位置</font></b>

68
01:04:55,291 --> 01:04:59,166
<b><font color='#ff9393'>结合"纹理->位置"获取当前表面与光源位置做差的单位矢量，</font></b>
<b><font color='#ff9393'>并为种子输入进噪波纹理中</font></b>

69
01:04:59,166 --> 01:05:06,416
<b><font color='#ff9393'>连接节点看看效果</font></b>

70
01:05:06,416 --> 01:05:10,875
<b><font color='#ff9393'>这样就做出了这种放射状的光斑</font></b>

71
01:05:16,416 --> 01:05:20,875
<b><font color='#ff9393'>这一部分的灵感来自于游戏《奥博拉丁的回归》</font></b>

72
01:05:20,875 --> 01:05:25,958
<b><font color='#ff9393'>所以想试试在blender中复现游戏中的发光贝壳特效</font></b>

73
01:05:25,958 --> 01:05:26,250
<b><font color='#ff9393'>在blender中复现游戏中的发光贝壳特效</font></b>
<b><font color='#ff9393'>(或许以后会出一期复刻这个游戏渲染风格的视频)</font></b>

74
01:05:26,250 --> 01:05:29,916
<b><font color='#ff9393'>先来看看球体材质是怎么做的</font></b>

75
01:05:29,916 --> 01:05:35,708
<b><font color='#ff9393'>这就是默认的棱角球+胡乱拼出来但看起来还行的材质</font></b>

76
01:05:35,708 --> 01:05:44,875
<b><font color='#ff9393'>至于球体外围的光芒，本质上是一个平面物体，</font></b>
<b><font color='#ff9393'>颜色效果是通过着色器节点程序生成的</font></b>

77
01:05:44,875 --> 01:05:53,041
<b><font color='#ff9393'>但是这个平面还没法自动指向摄像机，</font></b>
<b><font color='#ff9393'>只是平放在那里</font></b>

78
01:05:53,041 --> 01:06:06,875
<b><font color='#ff9393'>使用两个锁定追踪节点即可让这个平面，</font></b>
<b><font color='#ff9393'>时刻保持正面指向摄像机</font></b>

79
01:06:06,875 --> 01:06:31,333
<b><font color='#ff9393'>就像这样，这个平面就会自动指向摄像机，</font></b>
<b><font color='#ff9393'>无论摄像机移动到什么位置</font></b>

80
01:06:31,333 --> 01:06:48,708
<b><font color='#ff9393'>但是，在实际渲染的时候，会发现平面被一些东西挡住了，</font></b>
<b><font color='#ff9393'>假如想要让平面上的特效始终位于最前面呢？</font></b>

81
01:06:48,708 --> 01:06:53,541
<b><font color='#ff9393'>类似于，在合成的时候再将特效叠加上去，</font></b>
<b><font color='#ff9393'>这样能够保证特效不被任何东西阻挡</font></b>

82
01:06:53,541 --> 01:06:55,541
<b><font color='#ff9393'>这就需要你精准地给blender的合成器传递特效在屏幕空间的坐标</font></b>

83
01:06:55,541 --> 01:06:57,541
<b><font color='#ff9393'>以及渲染好的特效图片，如果特效是动态的，就更加费力了</font></b>

84
01:06:57,583 --> 01:07:02,583
<b><font color='#ff9393'>这里推荐一个又快又好的邪道方法，</font></b>
<b><font color='#ff9393'>轻松让你的最终画面"合成"这种无遮挡的效果</font></b>

85
01:07:03,458 --> 01:07:08,458
<b><font color='#ff9393'>为平面添加一个位置约束，物体选择摄像机</font></b>

86
01:07:10,375 --> 01:07:15,375
<b><font color='#ff9393'>调整一下"影响"的参数，让物体刚好位于摄像机的近裁剪平面之外</font></b>

87
01:07:15,375 --> 01:07:20,375
<b><font color='#ff9393'>手动缩放一下物体，让其在屏幕前是合适的大小</font></b>

88
01:07:24,375 --> 01:07:29,375
<b><font color='#ff9393'>这样你就间接地为blender增添了一项屏幕空间的渲染图层</font></b>

89
01:07:29,375 --> 01:07:34,375
<b><font color='#ff9393'>看，特效平面就在摄像机外面一点</font></b>

90
01:07:36,541 --> 01:07:38,416
<b><font color='#ff9393'>这是我第一次在blender中，</font></b>
<b><font color='#ff9393'>进行这种深度的像素化渲染尝试</font></b>

91
01:07:38,416 --> 01:07:40,291
<b><font color='#ff9393'>视频中的很多着色器节点，效果都是自己慢慢实验出来的</font></b>

92
01:07:40,291 --> 01:07:43,000
<b><font color='#ff9393'>但也令我感到很意外的是，很多常见的效果，</font></b>
<b><font color='#ff9393'>甚至是一些经典的处理方式都没有人做过在blender中实现的教程</font></b>

93
01:07:43,000 --> 01:07:44,875
<b><font color='#ff9393'>总之希望大家喜欢这类探索特殊风格的参考视频</font></b>

94
01:07:44,875 --> 01:07:46,750
<b><font color='#ff9393'>如果有更加巧妙的方法，也请告诉我</font></b>

95
01:07:46,750 --> 01:07:59,625
<b><font color='#ff9393'>总之喜欢的话可以去点个赞，谢谢喵</font></b>

